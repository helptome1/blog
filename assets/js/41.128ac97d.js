(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{569:function(e,n,t){"use strict";t.r(n);var r=t(8),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue的render函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的render函数"}},[e._v("#")]),e._v(" Vue的Render函数")]),e._v(" "),t("h3",{attrs:{id:"vue的整体流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的整体流程"}},[e._v("#")]),e._v(" Vue的整体流程")]),e._v(" "),t("p",[e._v("在学习render函数之前，咱们先看一下Vue的一些基本概念，从宏观了解vue的整体流程。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://secure2.wostatic.cn/static/qSEsYRsjqqCfxMkBzo1tyP/vue-render-1.jpg?auth_key=1679217275-pPvamZkQUFUDM3zMxf7p4v-0-8f584c2b84e0647c87744d3c3709e44a",alt:""}})]),e._v(" "),t("p",[e._v("从上图中，不难发现一个Vue的应用程序是如何运行起来的，模板通过编译生成AST，再由AST生成Vue")]),e._v(" "),t("p",[e._v("的"),t("code",[e._v("render")]),e._v("函数（渲染函数），渲染函数结合数据生成Virtual DOM树，Diff和Patch后生成新的UI。从")]),e._v(" "),t("p",[e._v("这张图中，可以接触到Vue的一些主要概念：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("模板")]),e._v("：Vue的模板基于纯HTML，基于Vue的模板语法，我们可以比较方便地声明数据和UI的关系。")]),e._v(" "),t("li",[t("strong",[e._v("AST")]),e._v("：AST是"),t("strong",[e._v("Abstract Syntax Tree")]),e._v("的简称，Vue使用HTML的Parser将HTML模板解析为AST，并且对AST进行一些优化的标记处理，提取最大的静态树，方便Virtual DOM时直接跳过Diff。")]),e._v(" "),t("li",[t("strong",[e._v("渲染函数")]),e._v("：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制 （这部分是我们今天主要要了解和学习的部分）。")]),e._v(" "),t("li",[t("strong",[e._v("Virtual DOM")]),e._v("：虚拟DOM树，Vue的Virtual DOM Patching算法是基于**"),t("a",{attrs:{href:"https://github.com/snabbdom/snabbdom",target:"_blank",rel:"noopener noreferrer"}},[e._v("Snabbdom"),t("OutboundLink")],1),e._v("**的实现，并在些基础上作了很多的调整和改进。")]),e._v(" "),t("li",[t("strong",[e._v("Watcher")]),e._v("：每个Vue组件都有一个对应的"),t("code",[e._v("watcher")]),e._v("，这个"),t("code",[e._v("watcher")]),e._v("将会在组件"),t("code",[e._v("render")]),e._v("的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染。你根本不需要写"),t("code",[e._v("shouldComponentUpdate")]),e._v("，Vue会自动优化并更新要更新的UI。")])]),e._v(" "),t("p",[t("code",[e._v("render")]),e._v("函数可以作为一道分割线，"),t("code",[e._v("render")]),e._v("函数的左边可以称之为"),t("strong",[e._v("编译期")]),e._v("，将Vue的模板转换为"),t("strong",[e._v("渲染函")])]),e._v(" "),t("p",[t("strong",[e._v("数")]),e._v("。"),t("code",[e._v("render")]),e._v("函数的右边是Vue的运行时，主要是基于渲染函数生成Virtual DOM树，Diff和Patch。")]),e._v(" "),t("h2",{attrs:{id:"render函数作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#render函数作用"}},[e._v("#")]),e._v(" render函数作用：")]),e._v(" "),t("p",[e._v("Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，真的需要 JavaScript 的完全")]),e._v(" "),t("p",[e._v("编程的能力。这时可以用渲染函数，它比模板更接近编译器。")]),e._v(" "),t("p",[t("code",[e._v("render")]),e._v(" 函数和 "),t("code",[e._v("template")]),e._v(" 一样都是创建 html 模板的，但是有些场景中用 template 实现起来代码冗长繁")]),e._v(" "),t("p",[e._v("琐而且有大量重复，这时候就可以用 render 函数。")]),e._v(" "),t("h2",{attrs:{id:"render函数的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#render函数的使用"}},[e._v("#")]),e._v(" render函数的使用")]),e._v(" "),t("p",[t("code",[e._v("render")]),e._v(" 函数即渲染函数，它是个函数接收两个参数，第一个参数 "),t("code",[e._v("createElement")]),e._v(" 也是个函数。第二个参数"),t("code",[e._v("context")]),e._v("存储了一些其他组件传过来的数据；")]),e._v(" "),t("p",[e._v("上边的代码中 "),t("code",[e._v("render: h => h(App)")]),e._v(" ，这是 ES6的箭头函数的写法，可以把 "),t("code",[e._v("h")]),e._v(" 当作 "),t("code",[e._v("createElement")]),e._v(" 的")]),e._v(" "),t("p",[e._v("别名。所以这段代码其实相当于：")]),e._v(" "),t("p",[e._v("render函数会return一个虚拟dom，return什么该组件就渲染什么")]),e._v(" "),t("div",{staticClass:"language-Vue extra-class"},[t("pre",{pre:!0,attrs:{class:"language-vue"}},[t("code",[e._v("export default {\n  name: 'Test',\n  // render作用:会return一个虚拟dom，return什么该组件就渲染什么\n  render: (h, context) => { // 第二个参数context存储了一些其他组件传过来的数据\n    console.log('context', context)\n    // h(标签名/组件,{虚拟dom配置},子集:子虚拟dom,也是虚拟dom节点信息,支持字符串与数组)\n    return h('h3', { class: 'abc' }, [h('h4', { class: 'abc2' }, '我是h4')])\n  }\n}\n")])])]),t("h3",{attrs:{id:"createelement函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createelement函数"}},[e._v("#")]),e._v(" createElement函数")]),e._v(" "),t("p",[e._v("这个函数的作用就是生成一个 VNode节点，render 函数得到这个 VNode 节点之后，返回给 Vue.js 的 mount 函数，渲染成真实 DOM 节点，并挂载到根节点上。")]),e._v(" "),t("p",[t("code",[e._v("createElement")]),e._v("接收三个参数，")]),e._v(" "),t("ol",[t("li",[e._v("一个 HTML 标签字符串，组件选项对象，或者解析上述任何一种的一个 async 异步函数。类型：String | Object | Function。必需。")]),e._v(" "),t("li",[e._v("一个包含模板相关属性的数据对象，你可以在 template 中使用这些特性。类型：Object。可选。")]),e._v(" "),t("li",[e._v("子虚拟节点 (VNodes)，由 createElement() 构建而成，也可以使用字符串来生成“文本虚拟节点”。类型：String | Array。可选。")])]),e._v(" "),t("div",{staticClass:"language-Vue extra-class"},[t("pre",{pre:!0,attrs:{class:"language-vue"}},[t("code",[e._v("createElement 参数\n\n// @return {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个HTML标签字符串，组件选项对象，或者一个返回值类型为String/Object的函数。该参数是必须的\n  'div',\n\n  // {Object}\n  // 一个包含模板相关属性的数据对象，这样我们可以在template中使用这些属性，该参数是可选的。\n  {\n    见下一个代码块\n  },\n\n  // {String | Array}\n  // 子节点（VNodes）由 createElement() 构建而成。可选参数\n  // 或简单的使用字符串来生成的 \"文本节点\"。\n  [\n    'xxxx',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'xxx'\n      }\n    })\n  ]\n)\n")])])]),t("p",[e._v("第二个参数，数据对象的具体参数。")]),e._v(" "),t("div",{staticClass:"language-Vue extra-class"},[t("pre",{pre:!0,attrs:{class:"language-vue"}},[t("code",[e._v("{\n  // 与 `v-bind:class` 的 API 相同，\n  // 接受一个字符串、对象或字符串和对象组成的数组\n  'class': {\n    foo: true,\n    bar: false\n  },\n  // 与 `v-bind:style` 的 API 相同，\n  // 接受一个字符串、对象，或对象组成的数组\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // 普通的 HTML attribute\n  attrs: {\n    id: 'foo'\n  },\n  // 组件 prop\n  props: {\n    myProp: 'bar'\n  },\n  // DOM property\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // 事件监听器在 `on` 内，\n  // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。\n  // 需要在处理函数中手动检查 keyCode。\n  on: {\n    click: this.clickHandler\n  },\n  // 仅用于组件，用于监听原生事件，而不是组件内部使用\n  // `vm.$emit` 触发的事件。\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`\n  // 赋值，因为 Vue 已经自动为你进行了同步。\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2',\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // 作用域插槽的格式为\n  // { name: props => VNode | Array"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("VNode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" }\n  scopedSlots: {\n    default: props => createElement('span', props.text)\n  },\n  // 如果组件是其它组件的子组件，需为插槽指定名称\n  slot: 'name-of-slot',\n  // 其它特殊顶层 property\n  key: 'myKey',\n  ref: 'myRef',\n  // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，\n  // 那么 `$refs.myRef` 会变成一个数组。\n  refInFor: true\n}\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);